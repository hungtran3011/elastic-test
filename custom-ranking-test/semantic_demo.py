from elasticsearch import Elasticsearch
import json

# Initialize Elasticsearch client
client = Elasticsearch("http://localhost:9200")

def wait_for_elasticsearch():
    import time
    for _ in range(60):
        try:
            if client.ping():
                print("Elasticsearch is ready.")
                return
        except Exception as e:
            print(f"Waiting for Elasticsearch... {e}")
            time.sleep(1)
    raise Exception("Elasticsearch not ready after 60 seconds")

def create_semantic_index():
    index_name = "my-semantic-index"
    mapping = {
        "mappings": {
            "properties": {
                "text_field": {
                    "type": "text"
                },
                "text_vector": {
                    "type": "dense_vector",
                    "dims": 3,  # Using 3D vectors for reliable demo
                    "index": True,
                    "similarity": "cosine"
                }
            }
        }
    }

    if client.indices.exists(index=index_name):
        client.indices.delete(index=index_name)
        print(f"Deleted existing index '{index_name}'.")
    client.indices.create(index=index_name, body=mapping)
    print(f"Created index '{index_name}' with semantic mapping.")

def insert_documents():
    index_name = "my-semantic-index"

    # Sample documents with 3-dimensional vectors for demo
    # In production, these would be generated by ML models like BERT, Sentence Transformers, etc.
    # For demo purposes, we'll create vectors that group similar concepts together
    
    # Programming-related vector (high values in first dimension)
    prog_vector = [0.9, 0.1, 0.0]
    
    # AI/ML-related vector (high values in second dimension)  
    ai_vector = [0.0, 0.9, 0.1]
    
    # Search/database-related vector (high values in third dimension)
    search_vector = [0.1, 0.0, 0.9]
    
    documents = [
        {
            "text_field": "I love programming with Python",
            "text_vector": prog_vector
        },
        {
            "text_field": "Machine learning is fascinating",
            "text_vector": ai_vector
        },
        {
            "text_field": "Elasticsearch is great for search",
            "text_vector": search_vector
        },
        {
            "text_field": "Natural language processing with transformers",
            "text_vector": ai_vector  # Similar to ML
        },
        {
            "text_field": "Vector search enables semantic matching",
            "text_vector": search_vector  # Similar to search
        }
    ]

    for i, doc in enumerate(documents):
        # Insert document
        client.index(index=index_name, id=i+1, body=doc)
        print(f"Inserted document {i+1}: {doc['text_field']}")

def semantic_search(query_text, query_vector, top_k=3):
    index_name = "my-semantic-index"

    # Modern kNN search using cosine similarity (defined in mapping)
    search_query = {
        "knn": {
            "field": "text_vector",
            "query_vector": query_vector,
            "k": top_k,
            "num_candidates": 10
        },
        "_source": ["text_field"]
    }

    response = client.search(index=index_name, body=search_query)

    print(f"\nCosine similarity kNN search results for: '{query_text}'")
    print("=" * 60)
    
    if response["hits"]["total"]["value"] == 0:
        print("No results found. This might be due to:")
        print("- Query vector not similar enough to document vectors")
        print("- Index not properly created")
        print("- Elasticsearch version compatibility")
        return response

    for hit in response["hits"]["hits"]:
        score = hit["_score"]
        text = hit["_source"]["text_field"]
        print(f"Score: {score:.4f} | Text: {text}")

    return response

def hybrid_search(query_text, query_vector, top_k=3):
    """Hybrid search combining BM25 keyword search with kNN vector search"""
    index_name = "my-semantic-index"
    
    # Simple combination: run both queries and merge results manually
    # Since RRF might not be available in all Elasticsearch versions
    
    # Keyword search
    keyword_query = {
        "query": {
            "match": {
                "text_field": query_text
            }
        },
        "size": top_k,
        "_source": ["text_field"]
    }
    
    # Vector search
    vector_query = {
        "knn": {
            "field": "text_vector",
            "query_vector": query_vector,
            "k": top_k,
            "num_candidates": 10
        },
        "_source": ["text_field"]
    }
    
    try:
        keyword_response = client.search(index=index_name, body=keyword_query)
        vector_response = client.search(index=index_name, body=vector_query)
        
        # Simple merging: combine and deduplicate results
        results = {}
        
        # Add keyword results with BM25 score
        for hit in keyword_response["hits"]["hits"]:
            doc_id = hit["_id"]
            results[doc_id] = {
                "text": hit["_source"]["text_field"],
                "keyword_score": hit["_score"],
                "vector_score": 0.0
            }
        
        # Add/update vector results
        for hit in vector_response["hits"]["hits"]:
            doc_id = hit["_id"]
            if doc_id in results:
                results[doc_id]["vector_score"] = hit["_score"]
            else:
                results[doc_id] = {
                    "text": hit["_source"]["text_field"],
                    "keyword_score": 0.0,
                    "vector_score": hit["_score"]
                }
        
        # Calculate combined score (simple average)
        for doc_id, data in results.items():
            data["combined_score"] = (data["keyword_score"] + data["vector_score"]) / 2
        
        # Sort by combined score
        sorted_results = sorted(results.items(), key=lambda x: x[1]["combined_score"], reverse=True)[:top_k]
        
        print(f"\nHybrid search (BM25 + Cosine kNN) results for: '{query_text}'")
        print("=" * 70)
        
        for doc_id, data in sorted_results:
            print(f"Combined Score: {data['combined_score']:.4f} | Text: {data['text']}")
        
        return sorted_results
        
    except Exception as e:
        print(f"Hybrid search failed: {e}")
        return None

if __name__ == "__main__":
    wait_for_elasticsearch()
    create_semantic_index()
    insert_documents()

    # Create query vectors for demo searches
    # Programming query vector (similar to programming documents)
    prog_query = [0.9, 0.1, 0.0]
    
    # AI/ML query vector (similar to AI documents)  
    ai_query = [0.0, 0.9, 0.1]
    
    # Search query vector (similar to search documents)
    search_query_vec = [0.1, 0.0, 0.9]

    print("\n" + "="*80)
    print("DEMO: Cosine Similarity Ranking with Elasticsearch kNN Search")
    print("="*80)
    
    # Demo kNN searches
    print("\n1. kNN Search Examples:")
    semantic_search("programming", prog_query)
    semantic_search("artificial intelligence", ai_query)
    semantic_search("database search", search_query_vec)
    
    # Demo hybrid search
    print("\n2. Hybrid Search Examples (BM25 + kNN combined):")
    hybrid_search("programming", prog_query)
    hybrid_search("machine learning", ai_query)
    hybrid_search("search", search_query_vec)
    
    print("\n" + "="*80)
    print("Note: This demo uses simplified 768D vectors for illustration.")
    print("In production: Use ML models (BERT, Sentence Transformers, etc.)")
    print("to generate semantically meaningful embeddings from your text.")
    print("="*80)